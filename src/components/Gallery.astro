---
import { galleryItems } from '@/data/gallery';
import type { GalleryItem } from '@/data/gallery';
import WaveDivider from '@/components/WaveDivider.astro';
import SectionHeader from '@/components/ui/SectionHeader.astro';

type Props = {
  id?: string;
  eyebrow?: string;
  heading?: string;
  description?: string;
  showTip?: boolean;
  /** Override the default placeholder gallery items. */
  items?: GalleryItem[];
  /** Render caption blocks below the image or as an overlay on top of the image. */
  variant?: 'below' | 'overlay';

  /** Back-compat single CTA (treated as primary). */
  ctaHref?: string;
  ctaLabel?: string;

  /** Optional dual CTAs (preferred going forward). */
  primaryCtaHref?: string;
  primaryCtaLabel?: string;
  secondaryCtaHref?: string;
  secondaryCtaLabel?: string;
};

const {
  id,
  eyebrow,
  heading = 'Gallery',
  description = 'A quick look at the spaces we support. Replace these placeholders with your own photos.',
  showTip = true,
  items,
  variant = 'below',
  ctaHref,
  ctaLabel,
  primaryCtaHref,
  primaryCtaLabel,
  secondaryCtaHref,
  secondaryCtaLabel,
} = Astro.props;

const base = import.meta.env.BASE_URL;

const resolvedPrimaryHref = primaryCtaHref ?? ctaHref;
const resolvedPrimaryLabel = primaryCtaLabel ?? ctaLabel;
const resolvedSecondaryHref = secondaryCtaHref;
const resolvedSecondaryLabel = secondaryCtaLabel;

const resolvedItems = Array.isArray(items) && items.length ? items : galleryItems;

const toPublicUrl = (src: string) => {
  // Allow absolute URLs
  if (/^https?:\/\//i.test(src)) return src;
  // Allow absolute-to-domain paths (we still want BASE_URL on GitHub Pages)
  const cleaned = src.replace(/^\/+/, '');
  return `${base}${cleaned}`;
};
---

<section id={id} class="section section-creative scroll-mt-20 pb-0">
  <div class="container-page relative">
    <SectionHeader eyebrow={eyebrow} heading={heading} description={description}>
      {
        (showTip ||
          (resolvedPrimaryHref && resolvedPrimaryLabel) ||
          (resolvedSecondaryHref && resolvedSecondaryLabel)) && (
          <div slot="actions" class="flex flex-col gap-2 sm:items-end">
            <div class="flex flex-col gap-2 sm:flex-row sm:justify-end">
              {resolvedSecondaryHref && resolvedSecondaryLabel && (
                <a class="btn-secondary px-4 py-2" href={resolvedSecondaryHref}>
                  {resolvedSecondaryLabel}
                </a>
              )}
              {resolvedPrimaryHref && resolvedPrimaryLabel && (
                <a class="btn-primary px-4 py-2" href={resolvedPrimaryHref}>
                  {resolvedPrimaryLabel}
                </a>
              )}
            </div>
            {showTip && (
              <p class="text-subtle text-sm">
                Tip: add images to
                <code class="border-app surface-muted mx-1 rounded border px-1.5 py-0.5">
                  public/gallery
                </code>
                .
              </p>
            )}
          </div>
        )
      }
    </SectionHeader>

    <div class="mt-10 grid gap-5 sm:grid-cols-2 lg:grid-cols-3" data-gallery>
      {
        resolvedItems.map((it, idx) => (
          <a
            href={toPublicUrl(it.src)}
            class:list={[
              'group overflow-hidden rounded-2xl border border-brand-100/50 bg-white/80 shadow-sm backdrop-blur-sm transition-all duration-300 hover:border-brand-200 hover:shadow-lg dark:border-brand-800/30 dark:bg-slate-900/50',
              variant === 'overlay' ? 'relative' : '',
            ]}
            data-gallery-item
            data-gallery-index={String(idx)}
          >
            <div class="relative aspect-[4/3] overflow-hidden">
              <img
                src={toPublicUrl(it.src)}
                alt={it.alt}
                loading="lazy"
                decoding="async"
                class="gallery-hover-zoom h-full w-full object-cover"
              />

              {variant === 'overlay' ? (
                <>
                  <div
                    aria-hidden="true"
                    class="pointer-events-none absolute inset-0 bg-gradient-to-t from-slate-950/70 via-slate-950/20 to-transparent"
                  />
                  <div class="pointer-events-none absolute inset-x-0 bottom-0 p-5">
                    <p class="text-sm font-semibold tracking-tight text-white">
                      {it.caption ?? 'Project photo'}
                    </p>
                    <p class="mt-1 line-clamp-2 text-xs text-white/75">{it.alt}</p>
                  </div>
                </>
              ) : null}
            </div>
            {variant === 'below' ? (
              <div class="p-5">
                <p class="text-strong text-sm font-semibold">{it.caption ?? 'Project photo'}</p>
                <p class="mt-1 text-sm text-muted">{it.alt}</p>
              </div>
            ) : null}
          </a>
        ))
      }
    </div>

    <dialog
      class="glass-card max-h-[calc(100dvh-2rem)] w-full max-w-3xl overflow-hidden rounded-2xl p-0"
      data-lightbox
    >
      <div class="border-app flex flex-wrap items-center justify-between gap-3 border-b px-5 py-4">
        <div class="min-w-0">
          <p class="text-strong truncate text-sm font-semibold" data-lightbox-title>Preview</p>
          <p class="text-subtle mt-0.5 text-xs" data-lightbox-count></p>
        </div>
        <div class="flex flex-wrap items-center gap-2">
          <button
            type="button"
            class="btn-secondary px-3 py-2"
            data-prev
            aria-label="Previous photo"
          >
            Prev
          </button>
          <button type="button" class="btn-secondary px-3 py-2" data-next aria-label="Next photo">
            Next
          </button>
          <button type="button" class="btn-secondary px-3 py-2" data-close>Close</button>
        </div>
      </div>
      <figure class="grid max-h-[calc(100dvh-9rem)] gap-3 overflow-auto p-5">
        <img
          data-lightbox-img
          alt=""
          class="border-app surface-muted w-full rounded-xl border object-contain"
        />
        <figcaption class="text-sm text-muted" data-lightbox-caption></figcaption>
      </figure>
    </dialog>
  </div>

  <div class="relative -mb-px mt-12">
    <WaveDivider tone="surface-muted" class="absolute bottom-0 left-0 right-0" />
  </div>

  <script>
    (() => {
      const root = document.querySelector('[data-gallery]');
      if (!root) return;

      const links = Array.from(root.querySelectorAll<HTMLAnchorElement>('a[data-gallery-item]'));
      const dialog = document.querySelector('dialog[data-lightbox]') as HTMLDialogElement | null;
      if (!dialog) return;

      const img = dialog.querySelector('[data-lightbox-img]') as HTMLImageElement | null;
      const caption = dialog.querySelector('[data-lightbox-caption]') as HTMLElement | null;
      const title = dialog.querySelector('[data-lightbox-title]') as HTMLElement | null;
      const count = dialog.querySelector('[data-lightbox-count]') as HTMLElement | null;
      const closeBtn = dialog.querySelector('[data-close]') as HTMLButtonElement | null;
      const prevBtn = dialog.querySelector('[data-prev]') as HTMLButtonElement | null;
      const nextBtn = dialog.querySelector('[data-next]') as HTMLButtonElement | null;

      const items = links.map((a) => {
        const href = a.getAttribute('href') || '';
        const imgEl = a.querySelector('img');
        const alt = imgEl?.getAttribute('alt') || '';
        const cap = a.querySelector('p')?.textContent || '';
        return { href, alt, caption: cap };
      });

      let currentIndex = 0;
      let previousOverflow: string | null = null;
      let previousScrollLock: string | null = null;
      let lastFocused: HTMLElement | null = null;

      const setScrollLock = (locked: boolean) => {
        const el = document.documentElement;
        if (locked) {
          if (previousScrollLock === null) previousScrollLock = el.dataset.scrollLock ?? null;
          el.dataset.scrollLock = 'true';
          if (previousOverflow === null) previousOverflow = el.style.overflow || '';
          el.style.overflow = 'hidden';
        } else {
          if (previousOverflow !== null) el.style.overflow = previousOverflow;
          previousOverflow = null;
          if (previousScrollLock !== null) {
            if (previousScrollLock === '') delete el.dataset.scrollLock;
            else el.dataset.scrollLock = previousScrollLock;
          } else {
            delete el.dataset.scrollLock;
          }
          previousScrollLock = null;
        }
      };

      const getFocusables = () => {
        const nodes = Array.from(
          dialog.querySelectorAll<HTMLElement>(
            'button:not([disabled]),a[href],input:not([disabled]),select:not([disabled]),textarea:not([disabled]),[tabindex]:not([tabindex="-1"])'
          )
        );
        return nodes.filter((el) => el.offsetParent !== null || el.getClientRects().length > 0);
      };

      const setContent = (index: number) => {
        const safeIndex = ((index % items.length) + items.length) % items.length;
        const it = items[safeIndex];
        currentIndex = safeIndex;

        if (img) {
          img.src = it?.href ?? '';
          img.alt = it?.alt ?? '';
        }
        if (caption) caption.textContent = it?.alt ?? '';
        if (title) title.textContent = it?.caption ? it.caption : 'Photo preview';
        if (count) count.textContent = items.length ? `${safeIndex + 1} of ${items.length}` : '';
      };

      const open = (index: number) => {
        if (!items.length) return;
        setContent(index);
        setScrollLock(true);
        lastFocused = document.activeElement as HTMLElement | null;
        if (typeof dialog.showModal === 'function') dialog.showModal();
        else dialog.setAttribute('open', '');
        // Move focus into the dialog for keyboard users.
        (closeBtn ?? getFocusables()[0])?.focus();
      };

      const close = () => {
        if (typeof dialog.close === 'function') dialog.close();
        else dialog.removeAttribute('open');
        setScrollLock(false);
        lastFocused?.focus?.();
        lastFocused = null;
      };

      const go = (delta: number) => {
        if (!items.length) return;
        setContent(currentIndex + delta);
      };

      // Swipe support (mobile)
      let touchStartX = 0;
      let touchStartY = 0;
      const onTouchStart = (e: TouchEvent) => {
        const t = e.touches?.[0];
        if (!t) return;
        touchStartX = t.clientX;
        touchStartY = t.clientY;
      };
      const onTouchEnd = (e: TouchEvent) => {
        const t = e.changedTouches?.[0];
        if (!t) return;
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        // Horizontal swipe threshold; ignore mostly-vertical gestures.
        if (Math.abs(dx) < 40 || Math.abs(dy) > 80) return;
        if (dx > 0) go(-1);
        else go(1);
      };

      links.forEach((a) => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          const idxStr = a.getAttribute('data-gallery-index');
          const idx = idxStr ? Number(idxStr) : 0;
          open(Number.isFinite(idx) ? idx : 0);
        });
      });

      closeBtn?.addEventListener('click', close);
      prevBtn?.addEventListener('click', () => go(-1));
      nextBtn?.addEventListener('click', () => go(1));
      dialog.addEventListener('click', (e) => {
        // Click outside the modal content closes it.
        if (e.target === dialog) close();
      });
      dialog.addEventListener('close', () => setScrollLock(false));
      dialog.addEventListener('touchstart', onTouchStart, { passive: true });
      dialog.addEventListener('touchend', onTouchEnd, { passive: true });

      document.addEventListener('keydown', (e) => {
        const isOpen = dialog.open || dialog.hasAttribute('open');
        if (!isOpen) return;
        if (e.key === 'Escape') close();
        if (e.key === 'ArrowLeft') go(-1);
        if (e.key === 'ArrowRight') go(1);

        if (e.key === 'Tab') {
          const focusables = getFocusables();
          if (!focusables.length) return;
          const first = focusables[0]!;
          const last = focusables[focusables.length - 1]!;
          const active = document.activeElement as HTMLElement | null;

          if (e.shiftKey) {
            if (!active || active === first) {
              e.preventDefault();
              last.focus();
            }
          } else {
            if (active === last) {
              e.preventDefault();
              first.focus();
            }
          }
        }
      });
    })();
  </script>
</section>
