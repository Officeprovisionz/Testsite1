---
import { getShuffledGalleryItems } from '@/data/gallery';
import type { GalleryItem } from '@/data/gallery';
import WaveDivider from '@/components/WaveDivider.astro';
import SectionHeader from '@/components/ui/SectionHeader.astro';
import { getPublicResponsiveImage } from '@/lib/publicImages';

type Props = {
  id?: string;
  eyebrow?: string;
  heading?: string;
  description?: string;
  showTip?: boolean;
  /** Optional auto-advance interval (ms) for mobile horizontal gallery browsing. */
  autoAdvanceMs?: number;
  /** Override the default placeholder gallery items. */
  items?: GalleryItem[];
  /** Render caption blocks below the image or as an overlay on top of the image. */
  variant?: 'below' | 'overlay';

  /** Back-compat single CTA (treated as primary). */
  ctaHref?: string;
  ctaLabel?: string;

  /** Optional dual CTAs (preferred going forward). */
  primaryCtaHref?: string;
  primaryCtaLabel?: string;
  secondaryCtaHref?: string;
  secondaryCtaLabel?: string;
};

const {
  id,
  eyebrow,
  heading = 'Gallery',
  description = 'A quick look at the spaces we support. Replace these placeholders with your own photos.',
  showTip = true,
  autoAdvanceMs,
  items,
  variant = 'below',
  ctaHref,
  ctaLabel,
  primaryCtaHref,
  primaryCtaLabel,
  secondaryCtaHref,
  secondaryCtaLabel,
} = Astro.props as Props;

const base = import.meta.env.BASE_URL;

const resolvedPrimaryHref = primaryCtaHref ?? ctaHref;
const resolvedPrimaryLabel = primaryCtaLabel ?? ctaLabel;
const resolvedSecondaryHref = secondaryCtaHref;
const resolvedSecondaryLabel = secondaryCtaLabel;

const resolvedItems =
  Array.isArray(items) && items.length ? items : getShuffledGalleryItems('gallery');

const toPublicUrl = (src: string) => {
  // Allow absolute URLs
  if (/^https?:\/\//i.test(src)) return src;
  // Allow absolute-to-domain paths (we still want BASE_URL on GitHub Pages)
  const cleaned = src.replace(/^\/+/, '');
  return `${base}${cleaned}`;
};

const getImgAttrs = (src: string) => {
  // Allow absolute URLs
  if (/^https?:\/\//i.test(src)) return { src, srcSet: undefined, sizes: undefined };

  const cleaned = src.replace(/^\/+/, '');
  if (/\.jpe?g$/i.test(cleaned)) {
    return getPublicResponsiveImage(cleaned, base, {
      sizes: '(min-width: 1024px) 33vw, (min-width: 640px) 50vw, 100vw',
    });
  }

  return { src: `${base}${cleaned}`, srcSet: undefined, sizes: undefined };
};
---

<section id={id} class="section section-creative scroll-mt-20 pb-0 lg:pt-28">
  <div class="container-page relative lg:max-w-7xl">
    <SectionHeader eyebrow={eyebrow} heading={heading} description={description}>
      {
        (showTip ||
          (resolvedPrimaryHref && resolvedPrimaryLabel) ||
          (resolvedSecondaryHref && resolvedSecondaryLabel)) && (
          <div slot="actions" class="flex flex-col gap-2 sm:items-end">
            <div class="flex flex-col gap-2 sm:flex-row sm:justify-end">
              {resolvedSecondaryHref && resolvedSecondaryLabel && (
                <a class="btn-secondary px-4 py-2" href={resolvedSecondaryHref}>
                  {resolvedSecondaryLabel}
                </a>
              )}
              {resolvedPrimaryHref && resolvedPrimaryLabel && (
                <a class="btn-primary px-4 py-2" href={resolvedPrimaryHref}>
                  {resolvedPrimaryLabel}
                </a>
              )}
            </div>
            {showTip && (
              <div class="flex flex-col gap-1">
                <p class="text-subtle text-sm sm:hidden">
                  Swipe to browse â†’ Tap a photo to preview.
                </p>
                <p class="text-subtle text-sm">
                  Tip: add images to
                  <code class="border-app surface-muted mx-1 rounded border px-1.5 py-0.5">
                    public/gallery
                  </code>
                  .
                </p>
              </div>
            )}
          </div>
        )
      }
    </SectionHeader>

    <div
      class="no-scrollbar -mx-4 mt-10 flex snap-x snap-mandatory gap-5 overflow-x-auto px-4 pb-2 md:mx-0 md:grid md:snap-none md:grid-cols-2 md:overflow-visible md:px-0 md:pb-0 lg:mt-14 lg:gap-6 xl:grid-cols-3"
      data-gallery
      data-auto-advance-ms={typeof autoAdvanceMs === 'number' ? String(autoAdvanceMs) : undefined}
    >
      {
        resolvedItems.map((it, idx) => {
          const attrs = getImgAttrs(it.src);
          return (
            <a
              href={toPublicUrl(it.src)}
              class:list={[
                'group w-[min(22rem,85vw)] shrink-0 snap-start overflow-hidden rounded-2xl border border-brand-100/60 bg-white/85 shadow-md backdrop-blur-sm transition-all duration-300 hover:border-brand-300 hover:shadow-xl dark:border-brand-800/30 dark:bg-slate-900/55 md:w-auto md:shrink md:snap-none',
                variant === 'overlay' ? 'relative' : '',
              ]}
              data-gallery-item
              data-gallery-index={String(idx)}
            >
              <div class="relative aspect-[4/3] overflow-hidden">
                <img
                  src={attrs.src}
                  srcset={attrs.srcSet}
                  alt={it.alt}
                  loading="lazy"
                  decoding="async"
                  fetchpriority="low"
                  sizes={
                    attrs.srcSet
                      ? attrs.sizes
                      : '(min-width: 1024px) 33vw, (min-width: 640px) 50vw, 100vw'
                  }
                  class="gallery-hover-zoom h-full w-full object-cover transition-transform duration-700"
                />

                {variant === 'overlay' ? (
                  <>
                    <div
                      aria-hidden="true"
                      class="pointer-events-none absolute inset-0 bg-gradient-to-t from-slate-950/85 via-slate-950/40 to-transparent transition-opacity duration-300 group-hover:from-slate-950/90"
                    />
                    <div class="pointer-events-none absolute inset-x-0 bottom-0 p-5 lg:p-6">
                      <p class="text-sm font-semibold tracking-tight text-white drop-shadow lg:text-base">
                        {it.caption ?? 'Project photo'}
                      </p>
                      <p class="mt-1 line-clamp-2 text-xs text-white/90 drop-shadow-sm lg:text-sm">
                        {it.alt}
                      </p>
                    </div>
                  </>
                ) : null}
              </div>
              {variant === 'below' ? (
                <div class="p-5 lg:p-6">
                  <p class="text-strong text-sm font-semibold lg:text-base">
                    {it.caption ?? 'Project photo'}
                  </p>
                  <p class="mt-1 text-sm text-muted lg:text-base">{it.alt}</p>
                </div>
              ) : null}
            </a>
          );
        })
      }
    </div>

    <dialog
      class="glass-card max-h-[calc(100dvh-2rem)] w-[calc(100%-1.25rem)] max-w-none overflow-hidden rounded-2xl p-0 sm:w-full sm:max-w-3xl"
      data-lightbox
      aria-label="Photo preview"
      aria-modal="true"
      role="dialog"
    >
      <div
        class="border-app flex flex-wrap items-center justify-between gap-3 border-b px-5 py-4"
        data-lightbox-chrome
      >
        <div class="min-w-0">
          <p class="text-strong truncate text-sm font-semibold" data-lightbox-title>Preview</p>
          <p class="text-subtle mt-0.5 text-xs" data-lightbox-count></p>
        </div>
        <div class="flex flex-wrap items-center gap-2">
          <button type="button" class="btn-secondary px-3 py-2" data-share aria-label="Share photo">
            Share
          </button>
          <button
            type="button"
            class="btn-secondary px-3 py-2"
            data-copy
            aria-label="Copy photo link"
          >
            Copy link
          </button>
          <button
            type="button"
            class="btn-secondary px-3 py-2"
            data-prev
            aria-label="Previous photo"
          >
            Prev
          </button>
          <button type="button" class="btn-secondary px-3 py-2" data-next aria-label="Next photo">
            Next
          </button>
          <button type="button" class="btn-secondary px-3 py-2" data-close>Close</button>
        </div>
      </div>
      <figure class="grid max-h-[calc(100dvh-9rem)] gap-3 overflow-auto p-5" data-lightbox-figure>
        <img
          data-lightbox-img
          alt=""
          class="border-app surface-muted mx-auto h-auto max-h-[min(68dvh,720px)] w-auto max-w-full rounded-xl border object-contain"
        />
        <figcaption class="text-sm text-muted" data-lightbox-caption data-lightbox-chrome>
        </figcaption>
        <p class="sr-only" aria-live="polite" data-lightbox-toast></p>
      </figure>
    </dialog>
  </div>

  <div class="relative -mb-px mt-12">
    <WaveDivider tone="surface-muted" class="absolute bottom-0 left-0 right-0" />
  </div>

  <script>
    (() => {
      const init = () => {
        const root = document.querySelector('[data-gallery]') as HTMLElement | null;
        if (!root) return;
        if (root.dataset.galleryInit === 'true') return;
        root.dataset.galleryInit = 'true';

        // Optional auto-advance for the horizontal (mobile) gallery.
        // Enabled only when a `data-auto-advance-ms` is present.
        const autoMsRaw = root.getAttribute('data-auto-advance-ms');
        const autoMs = autoMsRaw ? Number(autoMsRaw) : 0;

        const prefersReducedMotion = () => {
          try {
            return window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches ?? false;
          } catch {
            return false;
          }
        };

        const saveDataEnabled = () => {
          try {
            const nav = navigator as Navigator & { connection?: { saveData?: boolean } };
            return Boolean(nav.connection?.saveData);
          } catch {
            return false;
          }
        };

        const isHorizScrollable = () => {
          const el = root as HTMLElement;
          return el.scrollWidth > el.clientWidth + 24;
        };

        const links = Array.from(root.querySelectorAll<HTMLAnchorElement>('a[data-gallery-item]'));
        const dialog = document.querySelector('dialog[data-lightbox]') as HTMLDialogElement | null;
        if (!dialog) return;

        if (
          Number.isFinite(autoMs) &&
          autoMs > 0 &&
          !prefersReducedMotion() &&
          !saveDataEnabled()
        ) {
          let autoIndex = 0;
          let timer: number | undefined;
          let resumeTimer: number | undefined;

          const stop = () => {
            if (typeof timer === 'number') window.clearInterval(timer);
            timer = undefined;
          };

          const scheduleResume = () => {
            if (typeof resumeTimer === 'number') window.clearTimeout(resumeTimer);
            resumeTimer = window.setTimeout(() => {
              start();
            }, 8000);
          };

          const step = () => {
            if (!isHorizScrollable()) return;
            if (!links.length) return;
            if (document.hidden) return;

            autoIndex = (autoIndex + 1) % links.length;
            const el = links[autoIndex];
            el?.scrollIntoView?.({ behavior: 'smooth', inline: 'start', block: 'nearest' });
          };

          const start = () => {
            stop();
            if (!isHorizScrollable()) return;
            timer = window.setInterval(step, Math.max(1500, autoMs));
          };

          // Pause auto-advance on user interaction (they're browsing!).
          const onUserIntent = () => {
            stop();
            scheduleResume();
          };

          root.addEventListener('pointerdown', onUserIntent, { passive: true });
          root.addEventListener('touchstart', onUserIntent, { passive: true });
          root.addEventListener('wheel', onUserIntent, { passive: true });
          document.addEventListener('visibilitychange', () => {
            if (document.hidden) stop();
            else start();
          });

          // Start after first paint.
          window.setTimeout(start, 600);
        }

        const img = dialog.querySelector('[data-lightbox-img]') as HTMLImageElement | null;
        const caption = dialog.querySelector('[data-lightbox-caption]') as HTMLElement | null;
        const title = dialog.querySelector('[data-lightbox-title]') as HTMLElement | null;
        const count = dialog.querySelector('[data-lightbox-count]') as HTMLElement | null;
        const closeBtn = dialog.querySelector('[data-close]') as HTMLButtonElement | null;
        const prevBtn = dialog.querySelector('[data-prev]') as HTMLButtonElement | null;
        const nextBtn = dialog.querySelector('[data-next]') as HTMLButtonElement | null;
        const shareBtn = dialog.querySelector('[data-share]') as HTMLButtonElement | null;
        const copyBtn = dialog.querySelector('[data-copy]') as HTMLButtonElement | null;
        const toast = dialog.querySelector('[data-lightbox-toast]') as HTMLElement | null;
        const figure = dialog.querySelector('[data-lightbox-figure]') as HTMLElement | null;

        const items = links.map((a) => {
          const href = a.getAttribute('href') || '';
          const imgEl = a.querySelector('img');
          const alt = imgEl?.getAttribute('alt') || '';
          const cap = a.querySelector('p')?.textContent || '';
          return { href, alt, caption: cap };
        });

        let currentIndex = 0;
        let previousOverflow: string | null = null;
        let previousScrollLock: string | null = null;
        let lastFocused: HTMLElement | null = null;
        let toastTimer: number | undefined;

        const setScrollLock = (locked: boolean) => {
          const el = document.documentElement;
          if (locked) {
            if (previousScrollLock === null) previousScrollLock = el.dataset.scrollLock ?? null;
            el.dataset.scrollLock = 'true';
            el.dataset.modalOpen = 'true';
            if (previousOverflow === null) previousOverflow = el.style.overflow || '';
            el.style.overflow = 'hidden';
          } else {
            if (previousOverflow !== null) el.style.overflow = previousOverflow;
            previousOverflow = null;
            delete el.dataset.modalOpen;
            if (previousScrollLock !== null) {
              if (previousScrollLock === '') delete el.dataset.scrollLock;
              else el.dataset.scrollLock = previousScrollLock;
            } else {
              delete el.dataset.scrollLock;
            }
            previousScrollLock = null;
          }
        };

        const showToast = (message: string) => {
          if (!toast) return;
          toast.textContent = message;
          if (typeof toastTimer === 'number') window.clearTimeout(toastTimer);
          toastTimer = window.setTimeout(() => {
            toast.textContent = '';
          }, 1800);
        };

        const getFocusables = () => {
          const nodes = Array.from(
            dialog.querySelectorAll<HTMLElement>(
              'button:not([disabled]),a[href],input:not([disabled]),select:not([disabled]),textarea:not([disabled]),[tabindex]:not([tabindex="-1"])'
            )
          );
          return nodes.filter((el) => el.offsetParent !== null || el.getClientRects().length > 0);
        };

        const setContent = (index: number) => {
          const safeIndex = ((index % items.length) + items.length) % items.length;
          const it = items[safeIndex];
          currentIndex = safeIndex;

          if (img) {
            img.src = it?.href ?? '';
            img.alt = it?.alt ?? '';
          }
          if (caption) caption.textContent = it?.alt ?? '';
          if (title) title.textContent = it?.caption ? it.caption : 'Photo preview';
          if (count) count.textContent = items.length ? `${safeIndex + 1} of ${items.length}` : '';
        };

        const prefetchNeighbors = () => {
          if (!items.length) return;
          const indices = [currentIndex - 1, currentIndex + 1].map(
            (i) => ((i % items.length) + items.length) % items.length
          );
          indices.forEach((i) => {
            const href = items[i]?.href;
            if (!href) return;
            const pre = new Image();
            pre.decoding = 'async';
            pre.loading = 'eager';
            pre.src = href;
          });
        };

        const open = (index: number) => {
          if (!items.length) return;
          setContent(index);
          prefetchNeighbors();
          setScrollLock(true);
          lastFocused = document.activeElement as HTMLElement | null;
          if (typeof dialog.showModal === 'function') dialog.showModal();
          else dialog.setAttribute('open', '');
          // Move focus into the dialog for keyboard users.
          (closeBtn ?? getFocusables()[0])?.focus();
        };

        const close = () => {
          if (typeof dialog.close === 'function') dialog.close();
          else dialog.removeAttribute('open');
          setScrollLock(false);
          lastFocused?.focus?.();
          lastFocused = null;
        };

        const go = (delta: number) => {
          if (!items.length) return;
          setContent(currentIndex + delta);
          prefetchNeighbors();
        };

        const currentHref = () => {
          const it = items[currentIndex];
          return it?.href ?? '';
        };

        const currentShareTitle = () => {
          const it = items[currentIndex];
          return it?.caption ? it.caption : 'Photo';
        };

        const copyToClipboard = async (text: string) => {
          try {
            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
              await navigator.clipboard.writeText(text);
              showToast('Link copied.');
              return true;
            }
          } catch {
            // fall through
          }
          // Fallback: no clipboard access. Provide a manual copy affordance.
          try {
            window.prompt('Copy this link:', text);
            showToast('Copy manually.');
          } catch {
            showToast('Copy failed.');
          }
          return false;
        };

        // Gesture support (mobile): swipe left/right to navigate.
        // Scoped to the image area so buttons/chrome remain easy to tap.
        let touchStartX = 0;
        let touchStartY = 0;
        let touchLastX = 0;
        let touchLastY = 0;
        let touchMoved = false;

        const onTouchStart = (e: TouchEvent) => {
          const t = e.touches?.[0];
          if (!t) return;
          touchStartX = t.clientX;
          touchStartY = t.clientY;
          touchLastX = t.clientX;
          touchLastY = t.clientY;
          touchMoved = false;
        };

        const onTouchMove = (e: TouchEvent) => {
          const t = e.touches?.[0];
          if (!t) return;
          touchLastX = t.clientX;
          touchLastY = t.clientY;
          touchMoved = true;
        };

        const onTouchEnd = () => {
          if (!touchMoved) return;

          const dx = touchLastX - touchStartX;
          const dy = touchLastY - touchStartY;
          const absDx = Math.abs(dx);
          const absDy = Math.abs(dy);

          // Require a clear intent (avoid accidental diagonal scrolls).
          const horizontalIntent = absDx > 46 && absDx > absDy * 1.2;
          const verticalIntent = absDy > 140 && absDy > absDx * 1.25;

          if (horizontalIntent) {
            if (dx > 0) go(-1);
            else go(1);
            return;
          }

          // Optional: swipe down to close (only when scrolled to top).
          if (verticalIntent && dy > 0) {
            const atTop = !figure || figure.scrollTop <= 0;
            if (atTop) close();
          }
        };

        const toggleChrome = () => {
          const next = dialog.getAttribute('data-ui') === 'hidden' ? 'shown' : 'hidden';
          dialog.setAttribute('data-ui', next);
          const chromes = dialog.querySelectorAll<HTMLElement>('[data-lightbox-chrome]');
          chromes.forEach((el) => {
            el.style.opacity = next === 'hidden' ? '0' : '1';
            el.style.pointerEvents = next === 'hidden' ? 'none' : '';
          });
        };

        links.forEach((a) => {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const idxStr = a.getAttribute('data-gallery-index');
            const idx = idxStr ? Number(idxStr) : 0;
            open(Number.isFinite(idx) ? idx : 0);
          });
        });

        closeBtn?.addEventListener('click', close);
        prevBtn?.addEventListener('click', () => go(-1));
        nextBtn?.addEventListener('click', () => go(1));
        shareBtn?.addEventListener('click', async () => {
          const url = currentHref();
          if (!url) return;

          try {
            if (navigator.share) {
              await navigator.share({ title: currentShareTitle(), url });
              showToast('Shared.');
              return;
            }
          } catch {
            // share aborted or unavailable
          }

          await copyToClipboard(url);
        });
        copyBtn?.addEventListener('click', async () => {
          const url = currentHref();
          if (!url) return;
          await copyToClipboard(url);
        });

        // Tap image area to hide/show chrome (nice on mobile).
        figure?.addEventListener('click', (e) => {
          const target = e.target as HTMLElement | null;
          if (target?.tagName?.toLowerCase() === 'button') return;
          toggleChrome();
        });
        dialog.addEventListener('click', (e) => {
          // Click outside the modal content closes it.
          if (e.target === dialog) close();
        });
        dialog.addEventListener('close', () => setScrollLock(false));
        figure?.addEventListener('touchstart', onTouchStart, { passive: true });
        figure?.addEventListener('touchmove', onTouchMove, { passive: true });
        figure?.addEventListener('touchend', onTouchEnd, { passive: true });

        document.addEventListener('keydown', (e) => {
          const isOpen = dialog.open || dialog.hasAttribute('open');
          if (!isOpen) return;
          if (e.key === 'Escape') close();
          if (e.key === 'ArrowLeft') go(-1);
          if (e.key === 'ArrowRight') go(1);

          if (e.key === 'Tab') {
            const focusables = getFocusables();
            if (!focusables.length) return;
            const first = focusables[0]!;
            const last = focusables[focusables.length - 1]!;
            const active = document.activeElement as HTMLElement | null;

            if (e.shiftKey) {
              if (!active || active === first) {
                e.preventDefault();
                last.focus();
              }
            } else {
              if (active === last) {
                e.preventDefault();
                first.focus();
              }
            }
          }
        });
      };

      const doc = document.documentElement;
      if (doc.dataset.galleryListen !== 'true') {
        doc.dataset.galleryListen = 'true';
        document.addEventListener('astro:page-load', init);
      }

      init();
    })();
  </script>
</section>
